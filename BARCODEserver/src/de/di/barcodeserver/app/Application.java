package de.di.barcodeserver.app;

import de.di.barcodeserver.barcode.BarcodeProcessor;
import de.di.barcodeserver.barcode.Info;
import de.di.dokinform.license.ELOLicenseChecker;
import de.di.dokinform.util.ProductInfo;
import de.di.dokinform.util.Registry;
import de.di.license.check.LicenseException;
import de.di.license.check.LicenseKey;
import de.di.barcodeserver.elo.ELOClient;
import de.di.barcodeserver.jobs.SchedulableFactory;
import de.di.barcodeserver.profiles.ProfileException;
import de.di.barcodeserver.profiles.ProfileManager;
import de.elo.ix.client.IXExceptionData;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.DailyRollingFileAppender;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.PatternLayout;
import org.apache.log4j.spi.LoggingEvent;

public class Application extends Thread {

    private static Logger logger = null;
    /**
     * Properties object holding the settings for the application (e.g. input
     * directory etc.).
     */
    private static Properties settings = null;
    /**
     * The dispatcher checks the input directory for incoming files. If new
     * files are available they will be dispatched to the scheduler. The
     * dispatcher is a Singleton.
     */
    private Dispatcher dispatcher = null;
    /**
     * Flag inidcating that this thread is currnetly active/inactive.
     */
    private volatile boolean running = true;
    /**
     * Flag indicating that shutdown has been forced due to an error or
     * exception.
     */
    private volatile boolean forcedShutdown = false;
    /**
     * Buffer for logmessages generated by the start up sequence when writing to
     * the logfile is not possible yet.
     */
    private BufferHandler logHandler = null;
    /**
     * Handler for writing logmessages to the log file.
     */
    private DailyRollingFileAppender handler = null;
    /**
     * Shutdown hook to initiate a clean shutdown if the VM is terminated by
     * some event (e.g. the process is killed).
     */
    private ShutdownHandler shutdownHandler = null;
    /**
     * InputStream of the config file. It is either set by the constructor or
     * will be set during start up.
     */
    private InputStream configStream = null;
    /**
     * InputStream of the license file. It is either set by the constructor or
     * will be set during start up.
     */
    private InputStream licenseStream = null;
    private File profileDir = null;
    private ProfileManager profileManager = null;
    private java.net.URL configURL = null;
    /**
     * The status of the application. The data will be read from different
     * sources to dislplay it where appropriate
     */
    public java.util.Map<String, String> status = new java.util.Hashtable<String, String>();
    /**
     * Error information if startup failed due to an exception
     */
    private java.util.List<String> errorStatus = new java.util.ArrayList<String>();
    /**
     * The target database (to export to)
     */
    private ELOClient eloClient;
    private boolean oneTimePass = false;
    private int loginErrorCount = 0;

    /**
     * Constructor for application start up from the command line. It will use
     * null as the input stream for the config file. The application will set
     * the input stream in the start up sequence.
     */
    public Application() throws StartUpException {
        this(null);
    }

    /**
     * Constructor for application start up in a J2EE server environment which
     * will pass in the InputStream object of the config file.
     *
     * @param config input stream holding the configuration information
     * @param license input stream holding the license information
     */
    public Application(java.net.URL configURL) throws StartUpException {
        BasicConfigurator.configure();
        logger = Logger.getLogger(this.getClass().getPackage().getName());
        logHandler = new BufferHandler();
        logger.addAppender(logHandler);
//        logger.setUseParentHandlers(false);

        loadProductInfo();
        this.configURL = configURL;
    }

    @Override
    @SuppressWarnings("static-access")
    public void run() {
        logger.setLevel(Level.ALL);
        logger.log(Level.INFO, "Starting " + status.get("product")
                + " (Version: "  + status.get("version") + ")");

        //initiate start up sequence
        startUp();

        if (running == false) {
            logger.trace(getClass().getName() + ": run()");

            //logging to file not available yet
            if (handler == null) {
                for (LoggingEvent evt : logHandler.getEvents()) {
                    errorStatus.add(evt.getRenderedMessage());
                }
            }
            return;
        }

        //Add a shutdown hook
        shutdownHandler = new ShutdownHandler();
        Runtime.getRuntime().addShutdownHook(shutdownHandler);
//        logger.debug("Property user.dir: " + System.getProperty("user.dir"));

        logger.trace(getClass().getName() + "Startup complete");

        logger.debug("Entering main loop");

        //main loop waiting for shutdown
        while (running) {

            try {
                if (oneTimePass) {
                    dispatcher.join();
                    running = false;
                } else {
                    Thread.sleep(Integer.valueOf(settings.getProperty("Application.PollTime")));
                }
            } catch (InterruptedException iex) {
            } catch (Exception e) {
                logger.log(Level.FATAL,
                        "Unhandled exception occured! Please"
                        + " report the bug \nif possible with all information available\n"
                        + "to reproduce the problem. ", e);
            }

            if (running) {
                //an unhandled exception occured so shutdown immediately
                try {
                    if (!dispatcher.isAlive()) {
                        forceShutdown();
                    }
                } catch (NullPointerException npe) {
                }
            }

            if (running) {
                try {
                    eloClient.alive();
                    loginErrorCount = 0;
                } catch (java.rmi.RemoteException remote) {
                    loginErrorCount++; //increase error count
                    logger.debug("Error while keeping connection to ELO alive", remote);

                    if (loginErrorCount < 5) { //try 5 times to reconnect
                        try {
                            IXExceptionData data = eloClient.parseException(remote.getMessage());

                            if (data.getExceptionType() != eloClient.getServicePort().getIXEXCEPTION().NOT_IX) {
                                eloClient.logoff(); //try logging in again later
                            }
                        } catch (Exception ex) {
                            logger.error("Unable to keep connection to ELO alive");
                            forceShutdown();
                        }
                    } else {
                        logger.error("Unable to keep connection to ELO alive");
                        forceShutdown();
                    }

                } catch (Exception ex) {
                    logger.debug("Error while keeping connection to ELO alive", ex);
                    logger.error("Unable to keep connection to ELO alive");
                    forceShutdown();
                }
                try {
                    Thread.sleep(Integer.valueOf(settings.getProperty("Application.PollTime")));
                } catch (InterruptedException inex) {
                }
            }
        }

        //handle a clean shutdown
        if (!forcedShutdown) {

            if (logger != null) {
                logger.debug("Leaving main loop");
            }

            try {
                if (dispatcher != null) {
                    dispatcher.shutdown();
                    //wait for 5 seconds to shutdown the dispatcher
                    dispatcher.join(5000);
                }
            } catch (Exception e) {
            } finally {
                dispatcher = null;
            }

            settings = null;
        }

        if (eloClient != null) {
            //log off and release resources hold by the ELO client
            eloClient.logoff();
            eloClient = null;
        }

        if (handler != null) {
            if (logger != null) {
                logger.removeAppender(handler);
            }
//            handler.flush();

            handler.close();
            handler = null;
        }

        logger = null;

        //clear registry data
        Registry.getInstance().clear();
    }

    public void shutdown() {
        if (running == false) {
            return;
        }
        if (logger != null) {
            logger.info("Shutting down...");
        }

        running = false;

        interrupt();
    }
    /**
     * Force an immediate shutdown of the application.
     */
    public void forceShutdown() {
        logger.fatal("Focing shutdown");

        forcedShutdown = true;

        if (dispatcher != null) {
            dispatcher.shutdown();
            dispatcher = null;
        }
//        logger.removeHandler(handler);
//        handler.flush();

//        handler.close();
        try {
            if (shutdownHandler != null) {
                Runtime.getRuntime().removeShutdownHook(shutdownHandler);
            }
        } catch (IllegalStateException ise) {
        }
        shutdownHandler = null;
//        handler = null;
//        logger = null;
        settings = null;

        running = false;
        interrupt();
    }
    /**
     * Callback function for the status page to get some status information from
     * the running application.
     *
     * Currently the following information is available:
     *
     * Key: version, the version of the application Key: product_name, the
     * product name of the application Key: queue_size, the size of the queue
     * for incoming files Key: scheduler_status, status of the scheduler (true
     * if it is running, false otherwise) Key: queue_count, files currently
     * processed (only if scheduler is running!) Key: worker_count, number of
     * workers available (only if scheduler is running!) Key: dispatcher_status,
     * status of the dispatcher (true if it is running, false otherwise) Key:
     * active_job_count, number of open files (only if dispatcher is running!)
     *
     * @return java.util.Map<String, String> a map holding the status
     * information
     */
    public synchronized java.util.Map<String, String> getStatus() {

        if (dispatcher != null && dispatcher.isAlive()) {
            status.put("dispatcher_status", "true");
            status.put("dispatcher_state", dispatcher.getProcessingState().toString());
        } else {
            status.put("dispatcher_status", "false");
        }

        return status;
    }

    public synchronized java.util.List<String> getErrorStatus() {
        return errorStatus;
    }

    private void loadProductInfo() {
        InputStream in = getContextClassLoader().getResourceAsStream(
                "de/di/barcodeserver/app/resources/product.properties");

        if (in != null) {
            ProductInfo.readProductInfo(in, status);
        }
    }

    /**
     * Start up sequence of the application
     */
    private void startUp() {
        logger.trace(getClass().getName() + ": entering startUp()");
        try {
            java.net.URI configURI;

            if (configURL == null) {
                try {
                    configURI = new File("conf/").toURI();
                    File configDirectory = new File(configURI);
                    configStream = new FileInputStream(new File(configDirectory, "config.properties"));
                    Info.setConfig(new File(configDirectory, "config.properties"));
                    licenseStream = new FileInputStream(new File(configDirectory, "license.txt"));
                    profileDir = new File(configDirectory.getParentFile(), "profiles");
                } catch (Exception ex) {
                    errorStatus.add("Unable to initialize the application due to an exception: " + ex.getMessage());
                    throw new StartUpException("Application initialization failed", ex);
                }
            }

            if (configURL != null) {
                try {
                    File configDirectory = new File(configURL.toURI());
                    configURI = configURL.toURI();
                    configStream = new FileInputStream(new File(configDirectory, "config.properties"));
                    Info.setConfig(new File(configDirectory, "config.properties"));
                    licenseStream = new FileInputStream(new File(configDirectory, "license.txt"));
                    profileDir = new File(configDirectory.getParentFile(), "profiles");
                } catch (Exception ex) {
                    errorStatus.add("Unable to initialize the application due to an exception: " + ex.getMessage());
                    throw new StartUpException("Application initialization failed", ex);
                }
            }

            loadSettings();

            //simple check for a new installation
            boolean newInstall = Boolean.parseBoolean(settings.getProperty(
                    "Basic.NewInstall",
                    "TRUE"));

            if (newInstall) {
                logger.fatal("Service is deactivated. Aborting.");
                throw new StartUpException();
            }

            //check all required directories
            checkDirectories();

            //start logging to the log file
            startLogging();

            //basic configuration checks
            checkSettings();

            initELOClient();

            loadProfiles();

            checkLicense(profileManager.getProfileCount());

            SchedulableFactory fac = new SchedulableFactory(settings, eloClient, profileManager);

            //get the dispatcher
            //(thread hasn't been started yet!)
            dispatcher = new Dispatcher(settings, fac);

            //start up dispatcher to wait for incoming files
            dispatcher.start();
        } catch (StartUpException sex) {
            logger.trace("Startup exception: ", sex);
            logger.info("Unable to start the service.");
//            logger.removeHandler(logHandler);
//            logger.setUseParentHandlers(true);

//            for (LogRecord record : logHandler.getRecords()) {
//                logger.log(record);
//            }
            running = false;

            if (eloClient != null) {
                try {
                    eloClient.close();
                } catch (Exception ex) {
                }
            }
        }
        logger.trace(getClass().getName() + ": leaving startUp()");
    }

    /**
     * Read the settings from the configStream
     *
     * @throws de.arivato.erpconnect.ERPConnect.StartUpException
     */
    private void loadSettings() throws StartUpException {
        logger.trace(getClass().getName() + ": entering loadSettings()");
        settings = new Properties();

        File configFile = null;


        if (configStream == null) {
            try {
                configFile = new File("conf/config.properties");
            } catch (Exception ex) {
                logger.log(Level.FATAL, "Unable to locate config file.", ex);
                throw new StartUpException();
            }

            if (configFile.canRead() == false) {
                logger.log(Level.FATAL, "Unable to read config file '" + configFile.getAbsolutePath() + "'.");
                throw new StartUpException();
            }


            try {
                configStream = new FileInputStream(configFile);
            } catch (FileNotFoundException fex) {
                logger.log(Level.FATAL, "Config file '" + configFile.getAbsolutePath() + "' not found.");
                throw new StartUpException();
            }
        }

        try {
            settings.load(configStream);
            configStream.close();
        } catch (java.io.IOException ioex) {
            logger.log(Level.FATAL,
                    "Unable to read config file 'config.properties'.");
            logger.log(Level.FATAL, "File is corrupt!");
            throw new StartUpException();
        }
        Registry.getInstance().put("settings", settings);
        logger.trace(getClass().getName() + ": leaving loadSettings()");
    }

    /**
     * Start logging to the log file
     *
     * @throws de.arivato.erpconnect.ERPConnect.StartUpException
     */
    private void startLogging() throws StartUpException {
        logger.trace(getClass().getName() + ": startUp()");
        File logDir = null;

        try {
            logDir = new File(settings.getProperty("Directories.Logging"));
        } catch (NullPointerException nex) {
            logger.log(Level.FATAL, "Logging directory not found!");
            throw new StartUpException();
        }

        if (logDir.canWrite() == false) {
            logger.log(Level.FATAL, "Unable to write to log directory");
            throw new StartUpException();
        }

        String logfile;

        try {
            logfile = logDir.getCanonicalPath() + File.separator + "barcodeserver.log";
            handler = new DailyRollingFileAppender();
            handler.setDatePattern("'.'yyyy-MM-dd");
            handler.setFile(logfile);
            handler.setImmediateFlush(true);
            handler.setName("BARCODEserverAppender");

            String pattern = settings.getProperty("Basic.LoggingPattern",
                    "%d{dd.MM.yyyy HH:mm:ss} %-5p [%t]: %m%n");
            handler.setLayout(new PatternLayout(pattern));
            handler.activateOptions();

            Level logLevel = Level.toLevel(settings.getProperty("Basic.LogLevel", "WARN"), Level.WARN);

            logger.removeAppender(logHandler);
            Logger baseLogger = Logger.getLogger("de.di");
            baseLogger.addAppender(handler);
            baseLogger.setLevel(logLevel);

            for (LoggingEvent event : logHandler.getEvents()) {
                handler.doAppend(event);
            }

            logger = Logger.getLogger(getClass().getPackage().getName());

            Logger.getRootLogger().setLevel(Level.WARN);
//      Logger.getRootLogger().setLevel(Level.ALL);
            Logger.getRootLogger().removeAllAppenders();
//      Logger.getRootLogger().addAppender(handler);

            logHandler.close();
        } catch (java.io.IOException ioex) {
            logger.log(Level.FATAL, "Unable to create log file");
            throw new StartUpException();
        } catch (IllegalArgumentException iaex) {
            logger.log(Level.FATAL, "Illegal log level set");
            throw new StartUpException();
        }

        logger.trace(getClass().getName() + ": startUp()");
    }

    /**
     * Checks the directories for read and write access.
     *
     * @throws de.arivato.erpconnect.ERPConnect.StartUpException
     */
    private void checkDirectories() throws StartUpException {
        logger.trace(getClass().getName() + ": entering checkDirectories()");

        File dir = new File(settings.getProperty("Directories.Logging", ""));

        if (!dir.canWrite()) {
            logger.fatal("Logging directory not configured or not writable!\n"
                    + "Please edit config.properties accordingly or \nmake the "
                    + " directory writeable for the application.");
            throw new StartUpException();
        }

        logger.trace(getClass().getName() + ": leaving checkDirectories()");
    }

    /**
     * Method making some basic settings checks for consistency (e.g.
     * Index.TemplateFile doesn't point to non-existing file).
     *
     * @throws de.arivato.erpconnect.ERPConnect.StartUpException
     */
    private void checkSettings() throws StartUpException {
        logger.trace(getClass().getName() + ": entering checkSettings()");

        if (settings.getProperty("IndexServer.URL", "").length() == 0) {
            throw new StartUpException("URL for the index server not set!");
        }

        if (settings.getProperty("IndexServer.Password", "").length() == 0) {
            throw new StartUpException("Password for the index server not set!");
        }

        if (settings.getProperty("IndexServer.User", "").length() == 0) {
            throw new StartUpException("User for the index server not set!");
        }

        if (settings.getProperty("Agent.workflowsPerRun", "").length() == 0) {
            logger.warn(
                    "Number of workflows per run not set. Using default value 100.");
        } else {
            try {
                Integer.parseInt(settings.getProperty("Agent.workflowsPerRun"));
            } catch (NumberFormatException nfe) {
                logger.warn(
                        "Illegal number of workflows per run. Using default value 100.");
            }
        }

        logger.trace(getClass().getName() + ": leaving checkSettings()");
    }

    private void initELOClient() throws StartUpException {
        logger.trace(getClass().getName() + ": entering initELOClient()");

        String ix = settings.getProperty("IndexServer.URL");
        String user = settings.getProperty("IndexServer.User");
        String password = settings.getProperty("IndexServer.Password");
        
        // PWD: Decode ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++        
        String pattern = "^((\\d){1,})([-]{1}(\\d){1,}){1,}";
        java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern);
        java.util.regex.Matcher matcher = p.matcher(password);
        if(matcher.matches()) {            
            try {
                de.elo.utils.sec.DesEncryption des = new de.elo.utils.sec.DesEncryption();
                password = des.decrypt(password);
            } catch (Exception ex) {}            
        }
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        eloClient = new ELOClient();
        eloClient.setConnectionUrl(ix);
        eloClient.setUserName(user);
        eloClient.setPassword(password);
        eloClient.init();
        while (!eloClient.isConnected()) {
            try {
                eloClient.login();
            } catch (RemoteException ex) { //login failed
                for (StackTraceElement elem : ex.getStackTrace()) {
                    logger.trace(elem.getFileName() + ":" + elem.getLineNumber() + " "
                            + elem.getClassName() + "." + elem.getMethodName());
                }
                logger.debug("An exception occured while connecting to the index server.", ex);
                logger.error("Cannot connect to elo indexserver at the following addresses \'" + settings.getProperty("IndexServer.URL") + "\' ");
                try {
                    Thread.sleep(Integer.valueOf(settings.getProperty("Application.PollTime"))); //wait 5s for next try
                } catch (InterruptedException ex1) {
                }
            } catch(Exception ex){
                logger.debug("An exception occured while connecting to the index server.", ex);
                logger.error("Cannot connect to elo indexserver at the following addresses \'" + settings.getProperty("IndexServer.URL") + "\' ");
                try {
                    Thread.sleep(Integer.valueOf(settings.getProperty("Application.PollTime"))); //wait 5s for next try
                } catch (InterruptedException ex1) {
                }
            }
                    
        }
        ELOixIsReachable(eloClient);
        logger.trace(getClass().getName() + ": leaving initELOClient()");
    }

    private void loadProfiles() throws StartUpException {
        profileManager = new ProfileManager(eloClient);
        try {
            profileManager.loadProfiles(profileDir);
            BarcodeProcessor.setPropertiesMap(profileManager.getAllProfilesAsProperties());
        } catch (ProfileException ex) {
            logger.warn("An error occured while loading the profiles", ex);
            throw new StartUpException("Unable to load profiles from profiles directory");
        }

        logger.trace(getClass().getName() + ": leaving loadProfiles()");
    }

    private void checkLicense(int profileCount) throws StartUpException {
        logger.trace(getClass().getName() + ": entering checkLicense()");
        int maxProfiles = 0;

        try {
            ELOLicenseChecker checker = new ELOLicenseChecker(status.get("product"));
            checker.setSettings(settings);
            LicenseKey key;

            if (licenseStream != null) {
                key = LicenseKey.readFromFile(licenseStream);
                licenseStream.close();
            } else {
                key = LicenseKey.readFromFile(new File("conf/license.txt"));
            }

            checker.check(key, checker.getRounds());

            status.put("client", key.getAttribute("client").getValue());
            status.put("ELO_version", key.getAttribute("ELO-version").getValue());
            status.put("ERP_system", key.getAttribute("ERP-system").getValue());
            status.put("license_type", key.getAttribute("license-type").getValue());
            status.put("expiration_date", java.text.DateFormat.getDateInstance().format(key.getExpirationDate()));
            status.put("license_key", key.getAttribute("bytes2").getValue());

            checker = null;

            Pattern pattern = Pattern.compile("^(\\d+)\\s.*");
            Matcher matcher = pattern.matcher(key.getAttribute("license-type").getValue());
            String profiles = "0";

            if (matcher.matches()) {
                profiles = matcher.group(1);
            }

            try {
                maxProfiles = Integer.parseInt(profiles);
            } catch (NumberFormatException nfe) {
            }

            if (profileCount > maxProfiles) {
                throw new LicenseException("Profile count exceeded. Only " + maxProfiles
                        + " profiles allowed");
            }

            status.put("profileCount", Integer.toString(profileCount));
            status.put("maxProfiles", Integer.toString(maxProfiles));

            logger.trace(getClass().getName() + "Profile count: " + profileCount + " Max: " + maxProfiles);
        } catch (LicenseException lex) {
            logger.fatal("License violation detected: " + lex.getMessage());
            throw new StartUpException();
        } catch (java.io.IOException ioex) {
            logger.fatal("License check file corrupted", ioex);
            throw new StartUpException();
        } catch (java.security.NoSuchAlgorithmException ex) {
            logger.fatal("License check not possible");
            throw new StartUpException();
        }

        logger.trace(getClass().getName() + ": leaving checkLicense()");
    }
    
    // ------------------------- VERSION -------------------------------
    // +++ check the version of the application with IX version
    private void ELOixIsReachable(ELOClient client) throws IllegalStateException, StartUpException {
        running = false;                
        if (!isCompatible(client.getIndexServerVersion(), status.get("version"))) {
            throw new StartUpException("This version of " + status.get("version") + 
                    " is not certified for ELO Indexserver " + client.getIndexServerVersion() + ", please contact DOKinform for an update www.dokinform.ch");
        }
        running = true;        
    }

    private static boolean isCompatible(String ixVersion, String bcsVersion) {
        // to deactivate the checking version remove the comments
//        if (true) {
//            return true;
//        }
        if (ixVersion == null || ixVersion.isEmpty()) {
            logger.error("Could not check indexServer version. Version : " + ixVersion);
            return false;
        }
        if (bcsVersion == null || bcsVersion.isEmpty()) {
            logger.error("Could not check xml importer version. Version : " + bcsVersion);
            return false;
        }
        String ixMajor = ixVersion.split("\\.")[0];
        String xmlMajor = bcsVersion.split("\\.")[0];
        logger.info("Comparing sv : " + xmlMajor + " with ixv : " + ixMajor);
        return Integer.valueOf(xmlMajor) >= Integer.valueOf(ixMajor);
    }
    // +++ END MOD.

    /**
     * Inner class implementing the shutdown hook for the VM.
     */
    private class ShutdownHandler extends Thread {

        @Override
        public void run() {
//            shutdown();
            try {
                try {
                    Application.this.join();
                } catch (Exception e) {
                }

                //handler.flush();

            } catch (Exception e) {
            }
        }
    }

    /**
     * Handler for buffering log records durin start up.
     */
    private class BufferHandler extends org.apache.log4j.AppenderSkeleton {

        private ArrayList<LoggingEvent> events = new ArrayList<LoggingEvent>(30);

        BufferHandler() {
            super();
            super.setName(getClass().getName());
        }

        @Override
        protected void append(LoggingEvent event) {
            events.add(event);
        }

        @Override
        public void close() {
        }

        @Override
        public boolean requiresLayout() {
            return false;
        }

        public java.util.List<LoggingEvent> getEvents() {
            return events;
        }
    }
}
